// Code generated by protoc-gen-go. DO NOT EDIT.
// source: query/query.proto

/*
Package query is a generated protocol buffer package.

It is generated from these files:
	query/query.proto

It has these top-level messages:
	Query
	Result
*/
package query

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import metric "metric"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Domain Query struct. Used by domain-query and datapipeline-query
type Query struct {
	// A unique ID of this query (Will be included in the results)
	Id string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	// The remaining fields depend on the type of the query
	//
	// Types that are valid to be assigned to QueryType:
	//	*Query_AdHocQuery_
	//	*Query_TypedQuery_
	//	*Query_MetricQuery_
	QueryType isQuery_QueryType `protobuf_oneof:"query_type"`
}

func (m *Query) Reset()                    { *m = Query{} }
func (m *Query) String() string            { return proto.CompactTextString(m) }
func (*Query) ProtoMessage()               {}
func (*Query) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type isQuery_QueryType interface {
	isQuery_QueryType()
}

type Query_AdHocQuery_ struct {
	AdHocQuery *Query_AdHocQuery `protobuf:"bytes,3,opt,name=ad_hoc_query,json=adHocQuery,oneof"`
}
type Query_TypedQuery_ struct {
	TypedQuery *Query_TypedQuery `protobuf:"bytes,4,opt,name=typed_query,json=typedQuery,oneof"`
}
type Query_MetricQuery_ struct {
	MetricQuery *Query_MetricQuery `protobuf:"bytes,5,opt,name=metric_query,json=metricQuery,oneof"`
}

func (*Query_AdHocQuery_) isQuery_QueryType()  {}
func (*Query_TypedQuery_) isQuery_QueryType()  {}
func (*Query_MetricQuery_) isQuery_QueryType() {}

func (m *Query) GetQueryType() isQuery_QueryType {
	if m != nil {
		return m.QueryType
	}
	return nil
}

func (m *Query) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Query) GetAdHocQuery() *Query_AdHocQuery {
	if x, ok := m.GetQueryType().(*Query_AdHocQuery_); ok {
		return x.AdHocQuery
	}
	return nil
}

func (m *Query) GetTypedQuery() *Query_TypedQuery {
	if x, ok := m.GetQueryType().(*Query_TypedQuery_); ok {
		return x.TypedQuery
	}
	return nil
}

func (m *Query) GetMetricQuery() *Query_MetricQuery {
	if x, ok := m.GetQueryType().(*Query_MetricQuery_); ok {
		return x.MetricQuery
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Query) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Query_OneofMarshaler, _Query_OneofUnmarshaler, _Query_OneofSizer, []interface{}{
		(*Query_AdHocQuery_)(nil),
		(*Query_TypedQuery_)(nil),
		(*Query_MetricQuery_)(nil),
	}
}

func _Query_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Query)
	// query_type
	switch x := m.QueryType.(type) {
	case *Query_AdHocQuery_:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AdHocQuery); err != nil {
			return err
		}
	case *Query_TypedQuery_:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TypedQuery); err != nil {
			return err
		}
	case *Query_MetricQuery_:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MetricQuery); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Query.QueryType has unexpected type %T", x)
	}
	return nil
}

func _Query_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Query)
	switch tag {
	case 3: // query_type.ad_hoc_query
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Query_AdHocQuery)
		err := b.DecodeMessage(msg)
		m.QueryType = &Query_AdHocQuery_{msg}
		return true, err
	case 4: // query_type.typed_query
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Query_TypedQuery)
		err := b.DecodeMessage(msg)
		m.QueryType = &Query_TypedQuery_{msg}
		return true, err
	case 5: // query_type.metric_query
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Query_MetricQuery)
		err := b.DecodeMessage(msg)
		m.QueryType = &Query_MetricQuery_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Query_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Query)
	// query_type
	switch x := m.QueryType.(type) {
	case *Query_AdHocQuery_:
		s := proto.Size(x.AdHocQuery)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Query_TypedQuery_:
		s := proto.Size(x.TypedQuery)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Query_MetricQuery_:
		s := proto.Size(x.MetricQuery)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Fields needed for an ADHOC query
type Query_AdHocQuery struct {
	// The query string
	QueryString string `protobuf:"bytes,1,opt,name=query_string,json=queryString" json:"query_string,omitempty"`
	// Additional params needed to perform the query
	QueryParams map[string]string `protobuf:"bytes,2,rep,name=query_params,json=queryParams" json:"query_params,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Additional metadata associated with the query
	Metadata map[string]string `protobuf:"bytes,3,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Query_AdHocQuery) Reset()                    { *m = Query_AdHocQuery{} }
func (m *Query_AdHocQuery) String() string            { return proto.CompactTextString(m) }
func (*Query_AdHocQuery) ProtoMessage()               {}
func (*Query_AdHocQuery) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

func (m *Query_AdHocQuery) GetQueryString() string {
	if m != nil {
		return m.QueryString
	}
	return ""
}

func (m *Query_AdHocQuery) GetQueryParams() map[string]string {
	if m != nil {
		return m.QueryParams
	}
	return nil
}

func (m *Query_AdHocQuery) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// Fields needed for a TYPED query
type Query_TypedQuery struct {
	// The name of the type
	Type string `protobuf:"bytes,1,opt,name=type" json:"type,omitempty"`
}

func (m *Query_TypedQuery) Reset()                    { *m = Query_TypedQuery{} }
func (m *Query_TypedQuery) String() string            { return proto.CompactTextString(m) }
func (*Query_TypedQuery) ProtoMessage()               {}
func (*Query_TypedQuery) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 1} }

func (m *Query_TypedQuery) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

// Fields needed for a METRIC query
type Query_MetricQuery struct {
	// The ID of the metric in the catalog
	MetricId string `protobuf:"bytes,1,opt,name=metric_id,json=metricId" json:"metric_id,omitempty"`
	// The earliest (inclusive) timestamp desired
	Start int64 `protobuf:"varint,2,opt,name=start" json:"start,omitempty"`
	// The latest (inclusive) timestamp desired (set to 0 to get latest)
	End int64 `protobuf:"varint,3,opt,name=end" json:"end,omitempty"`
	// Return only the most recent X datapoints within the time range.
	Latest int32 `protobuf:"varint,4,opt,name=latest" json:"latest,omitempty"`
}

func (m *Query_MetricQuery) Reset()                    { *m = Query_MetricQuery{} }
func (m *Query_MetricQuery) String() string            { return proto.CompactTextString(m) }
func (*Query_MetricQuery) ProtoMessage()               {}
func (*Query_MetricQuery) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 2} }

func (m *Query_MetricQuery) GetMetricId() string {
	if m != nil {
		return m.MetricId
	}
	return ""
}

func (m *Query_MetricQuery) GetStart() int64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *Query_MetricQuery) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *Query_MetricQuery) GetLatest() int32 {
	if m != nil {
		return m.Latest
	}
	return 0
}

// Query result struct
type Result struct {
	// Identifies the ResultInstance that owns this data
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// Identifies the QueryInstance from which this ResultInstance was generated
	QueryId string `protobuf:"bytes,2,opt,name=queryId" json:"queryId,omitempty"`
	// Metadata associated with this result
	Metadata map[string]string `protobuf:"bytes,3,rep,name=metadata" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Timestamp when this result was retrieved
	Timestamp int64 `protobuf:"varint,4,opt,name=timestamp" json:"timestamp,omitempty"`
	// Result record
	//
	// Types that are valid to be assigned to Result:
	//	*Result_MetricResult
	//	*Result_MetaResult_
	Result isResult_Result `protobuf_oneof:"result"`
}

func (m *Result) Reset()                    { *m = Result{} }
func (m *Result) String() string            { return proto.CompactTextString(m) }
func (*Result) ProtoMessage()               {}
func (*Result) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type isResult_Result interface {
	isResult_Result()
}

type Result_MetricResult struct {
	MetricResult *metric.MetricZTS `protobuf:"bytes,5,opt,name=metric_result,json=metricResult,oneof"`
}
type Result_MetaResult_ struct {
	MetaResult *Result_MetaResult `protobuf:"bytes,7,opt,name=meta_result,json=metaResult,oneof"`
}

func (*Result_MetricResult) isResult_Result() {}
func (*Result_MetaResult_) isResult_Result()  {}

func (m *Result) GetResult() isResult_Result {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *Result) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Result) GetQueryId() string {
	if m != nil {
		return m.QueryId
	}
	return ""
}

func (m *Result) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Result) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Result) GetMetricResult() *metric.MetricZTS {
	if x, ok := m.GetResult().(*Result_MetricResult); ok {
		return x.MetricResult
	}
	return nil
}

func (m *Result) GetMetaResult() *Result_MetaResult {
	if x, ok := m.GetResult().(*Result_MetaResult_); ok {
		return x.MetaResult
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Result) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Result_OneofMarshaler, _Result_OneofUnmarshaler, _Result_OneofSizer, []interface{}{
		(*Result_MetricResult)(nil),
		(*Result_MetaResult_)(nil),
	}
}

func _Result_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Result)
	// result
	switch x := m.Result.(type) {
	case *Result_MetricResult:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MetricResult); err != nil {
			return err
		}
	case *Result_MetaResult_:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.MetaResult); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Result.Result has unexpected type %T", x)
	}
	return nil
}

func _Result_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Result)
	switch tag {
	case 5: // result.metric_result
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(metric.MetricZTS)
		err := b.DecodeMessage(msg)
		m.Result = &Result_MetricResult{msg}
		return true, err
	case 7: // result.meta_result
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Result_MetaResult)
		err := b.DecodeMessage(msg)
		m.Result = &Result_MetaResult_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Result_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Result)
	// result
	switch x := m.Result.(type) {
	case *Result_MetricResult:
		s := proto.Size(x.MetricResult)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Result_MetaResult_:
		s := proto.Size(x.MetaResult)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Result_MetaResult struct {
	Count int64 `protobuf:"varint,6,opt,name=count" json:"count,omitempty"`
}

func (m *Result_MetaResult) Reset()                    { *m = Result_MetaResult{} }
func (m *Result_MetaResult) String() string            { return proto.CompactTextString(m) }
func (*Result_MetaResult) ProtoMessage()               {}
func (*Result_MetaResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 1} }

func (m *Result_MetaResult) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func init() {
	proto.RegisterType((*Query)(nil), "query.Query")
	proto.RegisterType((*Query_AdHocQuery)(nil), "query.Query.AdHocQuery")
	proto.RegisterType((*Query_TypedQuery)(nil), "query.Query.TypedQuery")
	proto.RegisterType((*Query_MetricQuery)(nil), "query.Query.MetricQuery")
	proto.RegisterType((*Result)(nil), "query.Result")
	proto.RegisterType((*Result_MetaResult)(nil), "query.Result.MetaResult")
}

func init() { proto.RegisterFile("query/query.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 515 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x54, 0xd1, 0x6e, 0xd3, 0x30,
	0x14, 0x5d, 0x92, 0x25, 0x6b, 0x6f, 0x3a, 0xb4, 0x19, 0x04, 0x51, 0x8a, 0x44, 0xa9, 0x84, 0xd4,
	0xa7, 0x4c, 0x1a, 0x0f, 0x4c, 0xab, 0x40, 0x5a, 0x25, 0xa4, 0x4e, 0x68, 0xd2, 0xc8, 0xf6, 0xc4,
	0x4b, 0x65, 0x6a, 0xab, 0x04, 0x9a, 0xa4, 0x38, 0x2e, 0x52, 0xf7, 0x49, 0x7c, 0x03, 0x7f, 0xc4,
	0x4f, 0x20, 0xdf, 0xeb, 0x24, 0x2b, 0xd0, 0x07, 0xc4, 0x4b, 0xeb, 0x73, 0x7d, 0xcf, 0xf5, 0x71,
	0xce, 0x49, 0xe0, 0xf8, 0xeb, 0x5a, 0xaa, 0xcd, 0x09, 0xfe, 0x26, 0x2b, 0x55, 0xea, 0x92, 0xf9,
	0x08, 0xe2, 0x87, 0xb9, 0xd4, 0x2a, 0x9b, 0x9f, 0xd0, 0x1f, 0xed, 0x0d, 0xbf, 0xfb, 0xe0, 0xbf,
	0x37, 0xdb, 0xec, 0x01, 0xb8, 0x99, 0x88, 0xdc, 0x81, 0x33, 0xea, 0xa6, 0x6e, 0x26, 0xd8, 0x18,
	0x7a, 0x5c, 0xcc, 0x3e, 0x95, 0xf3, 0x19, 0xd2, 0x23, 0x6f, 0xe0, 0x8c, 0xc2, 0xd3, 0x27, 0x09,
	0x4d, 0x46, 0x4e, 0x72, 0x21, 0xa6, 0xe5, 0x1c, 0x97, 0xd3, 0xbd, 0x14, 0x78, 0x83, 0xd8, 0x39,
	0x84, 0x7a, 0xb3, 0x92, 0xc2, 0x72, 0xf7, 0xff, 0xc2, 0xbd, 0x35, 0xfb, 0x0d, 0x57, 0x37, 0x88,
	0xbd, 0x86, 0x1e, 0x49, 0xb4, 0x64, 0x1f, 0xc9, 0xd1, 0x16, 0xf9, 0x0a, 0x1b, 0x6a, 0x76, 0x98,
	0xb7, 0x30, 0xfe, 0xe1, 0x02, 0xb4, 0xba, 0xd8, 0x73, 0xe8, 0x21, 0x71, 0x56, 0x69, 0x95, 0x15,
	0x8b, 0xc8, 0xc1, 0x0b, 0x86, 0x58, 0xbb, 0xc1, 0x12, 0x7b, 0x57, 0xb7, 0xac, 0xb8, 0xe2, 0x79,
	0x15, 0xb9, 0x03, 0x6f, 0x14, 0x9e, 0x8e, 0x76, 0xdc, 0x94, 0x0a, 0xd7, 0xd8, 0xfa, 0xb6, 0xd0,
	0x6a, 0x63, 0x87, 0x51, 0x85, 0x5d, 0x40, 0x27, 0x97, 0x9a, 0x0b, 0xae, 0x79, 0xe4, 0xe1, 0xa0,
	0x17, 0xbb, 0x06, 0x5d, 0xd9, 0x3e, 0x9a, 0xd2, 0xd0, 0xe2, 0x37, 0x70, 0xf4, 0xfb, 0x19, 0xec,
	0x08, 0xbc, 0x2f, 0x72, 0x63, 0xd5, 0x9b, 0x25, 0x7b, 0x04, 0xfe, 0x37, 0xbe, 0x5c, 0x4b, 0x6b,
	0x19, 0x81, 0x73, 0xf7, 0xcc, 0x89, 0xc7, 0x70, 0xb8, 0x35, 0xfa, 0x9f, 0xc8, 0x03, 0x80, 0xd6,
	0x19, 0xc6, 0x60, 0xdf, 0x38, 0x63, 0xa9, 0xb8, 0x8e, 0x3f, 0x43, 0x78, 0xef, 0xf1, 0xb3, 0x3e,
	0x74, 0xad, 0x5d, 0x99, 0xb0, 0x7d, 0x1d, 0x2a, 0x5c, 0x0a, 0x73, 0x4e, 0xa5, 0xb9, 0xd2, 0x78,
	0x8e, 0x97, 0x12, 0x30, 0x7a, 0x64, 0x21, 0x30, 0x51, 0x5e, 0x6a, 0x96, 0xec, 0x31, 0x04, 0x4b,
	0xae, 0x65, 0xa5, 0x31, 0x2a, 0x7e, 0x6a, 0xd1, 0xa4, 0x07, 0x40, 0xd6, 0x98, 0x93, 0x87, 0x3f,
	0x5d, 0x08, 0x52, 0x59, 0xad, 0x97, 0xda, 0xa6, 0xd5, 0x69, 0xd2, 0x1a, 0xc1, 0x01, 0x36, 0x5e,
	0xd6, 0x11, 0xae, 0x21, 0x7b, 0xf5, 0x87, 0x21, 0x7d, 0x6b, 0x08, 0x8d, 0xda, 0x65, 0x03, 0x7b,
	0x0a, 0x5d, 0x9d, 0xe5, 0xb2, 0xd2, 0x3c, 0x5f, 0xa1, 0x2c, 0x2f, 0x6d, 0x0b, 0xec, 0x0c, 0x0e,
	0xed, 0xb5, 0x15, 0x8e, 0xb1, 0x31, 0x3d, 0x4e, 0xec, 0xeb, 0x45, 0x8f, 0xe8, 0xc3, 0xed, 0xcd,
	0x74, 0x2f, 0xb5, 0x79, 0xb6, 0xd2, 0xc7, 0x60, 0xf2, 0xca, 0x6b, 0xde, 0xc1, 0x56, 0xbc, 0xef,
	0x69, 0xa2, 0xa5, 0x79, 0x39, 0xf2, 0x06, 0xfd, 0x9f, 0xb7, 0x43, 0x80, 0x76, 0xb0, 0xe9, 0x9b,
	0x97, 0xeb, 0x42, 0x47, 0x01, 0x79, 0x83, 0x60, 0xd2, 0x81, 0x80, 0x84, 0x4d, 0x9e, 0x41, 0xbf,
	0x54, 0x8b, 0xe4, 0x4e, 0x16, 0x65, 0x55, 0x25, 0x77, 0x59, 0xb1, 0xa0, 0x6f, 0x06, 0x29, 0xbd,
	0x76, 0x3e, 0x06, 0x08, 0x5f, 0xfe, 0x0a, 0x00, 0x00, 0xff, 0xff, 0x11, 0xa8, 0xe8, 0x6d, 0x73,
	0x04, 0x00, 0x00,
}
